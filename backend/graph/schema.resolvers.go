package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.22

import (
	"context"
	"fmt"
	"net/http"
	"strconv"

	"github.com/sijysn/resistar/backend/graph/generated"
	"github.com/sijysn/resistar/backend/graph/model"
	"github.com/sijysn/resistar/backend/internal/auth"
	"github.com/sijysn/resistar/backend/internal/middleware"
	dbModel "github.com/sijysn/resistar/backend/internal/model"
	"github.com/sijysn/resistar/backend/internal/sql"
)

// AddHistory is the resolver for the addHistory field.
func (r *mutationResolver) AddHistory(ctx context.Context, input model.NewHistory) (*model.History, error) {
	responseAccess := ctx.Value(middleware.ResponseAccessKey).(*middleware.ResponseAccess)
	if responseAccess.Status == http.StatusInternalServerError {
		return nil, fmt.Errorf("サーバーエラーが発生しました")
	}
	if responseAccess.Status != auth.StatusGroup {
		errorMessage := "認証されていません"
		return &model.History{
			ErrorMessage: &errorMessage,
		}, nil
	}

	var dbFromUsers []dbModel.User
	err := r.DB.Where(input.FromUserIds).Find(&dbFromUsers).Error
	if err != nil {
		return nil, err
	}

	var dbToUsers []dbModel.User
	err = r.DB.Where(input.ToUserIds).Find(&dbToUsers).Error
	if err != nil {
		return nil, err
	}

	groupID, err := strconv.ParseUint(input.GroupID, 10, 64)
	if err != nil {
		return nil, err
	}

	dbNewHistory := &dbModel.History{
		Title:   input.Title,
		Type:    model.Type(input.Type),
		Price:   input.Price,
		GroupID: uint(groupID),
	}

	var newHistory *model.History
	err = r.DB.Create(dbNewHistory).Error
	if err != nil {
		return nil, err
	}
	err = r.DB.Model(dbNewHistory).Association("FromUsers").Append(dbFromUsers)
	if err != nil {
		return nil, err
	}
	err = r.DB.Model(dbNewHistory).Association("ToUsers").Append(dbToUsers)
	if err != nil {
		return nil, err
	}

	err = sql.AddBalances(r.DB, input.Price, dbFromUsers, dbToUsers, dbNewHistory.CreatedAt, dbNewHistory.UpdatedAt, dbNewHistory.ID, uint(groupID))
	if err != nil {
		return nil, err
	}

	newHistory = &model.History{
		ID:        strconv.FormatUint(uint64(dbNewHistory.ID), 10),
		Title:     dbNewHistory.Title,
		Type:      dbNewHistory.Type,
		Price:     dbNewHistory.Price,
		CreatedAt: dbNewHistory.CreatedAt.Format("2006-01-02 15:04:05"),
	}

	return newHistory, nil
}

// AddUser is the resolver for the addUser field.
func (r *mutationResolver) AddUser(ctx context.Context, input model.NewUser) (*model.Result, error) {
	result, err := r.Usecase.AddUser(ctx, input)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// AddGroup is the resolver for the addGroup field.
func (r *mutationResolver) AddGroup(ctx context.Context, input model.NewGroup) (*model.Result, error) {
	result, err := r.Usecase.AddGroup(ctx, input)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// InviteUserToGroup is the resolver for the inviteUserToGroup field.
func (r *mutationResolver) InviteUserToGroup(ctx context.Context, input model.InviteUserToGroupInput) (*model.Result, error) {
	result, err := r.Usecase.InviteUserToGroup(ctx, input)
	if err != nil {
		return nil, err
	}
	return result, err
}

// JoinGroup is the resolver for the joinGroup field.
func (r *mutationResolver) JoinGroup(ctx context.Context, input model.JoinGroup) (*model.Result, error) {
	result, err := r.Usecase.JoinGroup(ctx, input)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// LoginUser is the resolver for the loginUser field.
func (r *mutationResolver) LoginUser(ctx context.Context, input model.LoginUser) (*model.Result, error) {
	result, err := r.Usecase.LoginUser(ctx, input)
	if err != nil {
		return nil, err
	}
	return result, err
}

// LoginGroup is the resolver for the loginGroup field.
func (r *mutationResolver) LoginGroup(ctx context.Context, input model.LoginGroup) (*model.Result, error) {
	result, err := r.Usecase.LoginGroup(ctx, input)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// LogoutGroup is the resolver for the logoutGroup field.
func (r *mutationResolver) LogoutGroup(ctx context.Context) (*model.Result, error) {
	result, err := r.Usecase.LogoutGroup(ctx)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Histories is the resolver for the histories field.
func (r *queryResolver) Histories(ctx context.Context, input model.HistoriesQuery) ([]*model.History, error) {
	histories, err := r.Usecase.GetHistories(ctx, input)
	if err != nil {
		return nil, err
	}
	return histories, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, input model.UsersQuery) ([]*model.User, error) {
	users, err := r.Usecase.GetUsers(ctx, input)
	if err != nil {
		return nil, err
	}
	return users, nil
}

// Groups is the resolver for the groups field.
func (r *queryResolver) Groups(ctx context.Context, input model.GroupsQuery) ([]*model.Group, error) {
	groups, err := r.Usecase.GetGroups(ctx, input)
	if err != nil {
		return nil, err
	}
	return groups, nil
}

// Amounts is the resolver for the amounts field.
func (r *queryResolver) Amounts(ctx context.Context, input model.AmountsQuery) (*model.Amounts, error) {
	amounts, err := r.Usecase.GetAmounts(ctx, input)
	if err != nil {
		return nil, err
	}
	return amounts, nil
}

// Adjustments is the resolver for the adjustments field.
func (r *queryResolver) Adjustments(ctx context.Context, input model.AdjustmentQuery) ([]*model.Adjustment, error) {
	adjustments, err := r.Usecase.GetAdjustments(ctx, input)
	if err != nil {
		return nil, err
	}
	return adjustments, nil
}

// GroupsWhereUserHasBeenInvited is the resolver for the groupsWhereUserHasBeenInvited field.
func (r *queryResolver) GroupsWhereUserHasBeenInvited(ctx context.Context, input model.GroupsQuery) ([]*model.Group, error) {
	groups, err := r.Usecase.GetGroupsWhereUserHasBeenInvited(ctx, input)
	if err != nil {
		return nil, err
	}
	return groups, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
